// Generated by CoffeeScript 1.8.0
(function() {
  var async, fs, merge, parseData, parsePaths, readData, unwrap, utils, yaml, _,
    __slice = [].slice;

  fs = require('fs');

  fs.path = require('path');

  async = require('async');

  _ = require('underscore');

  yaml = require('js-yaml');

  utils = require('./utils');

  unwrap = utils.string.unwrap;

  parsePaths = function(paths, options) {
    var extension, extensionlessFilename, filename, namespace, path, segments, _i, _len, _ref, _results;
    if (paths == null) {
      paths = [];
    }
    _ref = _.compact(paths.split(','));
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      path = _ref[_i];
      segments = path.split(':');
      filename = segments.pop();
      namespace = segments.pop();
      extension = fs.path.extname(path);
      if (!namespace) {
        if (options.fullyNamespaced) {
          namespace = fs.path.basename(filename, extension);
        } else if (options.namespaced) {
          extensionlessFilename = filename.slice(0, -extension.length);
          namespace = extensionlessFilename.replace(/\//g, '.');
        }
      }
      _results.push({
        filename: filename,
        namespace: namespace
      });
    }
    return _results;
  };

  readData = function(path) {
    var resolvedPath;
    resolvedPath = fs.path.resolve(path);
    return fs.readFileSync(resolvedPath, {
      encoding: 'utf8'
    });
  };

  parseData = function(raw, extension) {
    switch (extension) {
      case '.json':
        return JSON.parse(raw);
      case '.yml':
      case '.yaml':
        return yaml.safeLoad(raw);
      default:
        throw new Error("Context files need to be JSON or YAML.");
    }
  };

  merge = function() {
    var add, destination, source, sources, _i, _len;
    sources = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      if (source.data.constructor === Array && source.namespace) {
        source.data = utils.kv(source.namespace, source.data);
        source.namespace = false;
      }
      if (typeof destination === "undefined" || destination === null) {
        switch (source.data.constructor) {
          case Array:
            destination = [];
            add = function(items) {
              return destination.push.apply(destination, items);
            };
            break;
          case Object:
            destination = {};
            add = function(hash) {
              return _.extend(destination, hash);
            };
            break;
          default:
            throw new Error(unwrap("Can only merge data from objects or arrays. Instead got: " + source.constructor));
        }
      }
      if (source.data.constructor !== destination.constructor) {
        throw new Error(unwrap("Mixed data types. Expected: " + destination.constructor.name + ". Instead got: " + source.constructor.name + "."));
      }
      if (destination.constructor === Object && source.namespace) {
        utils.set(destination, source.namespace, source.data);
      } else {
        add(source.data);
      }
    }
    return destination;
  };

  exports.load = function(pathList, options) {
    var extension, filename, namespace, path, paths, raw, _i, _len;
    paths = parsePaths(pathList, _.pick(options, 'namespaced', 'fullyNamespaced'));
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      path = paths[_i];
      filename = path.filename, namespace = path.namespace;
      extension = fs.path.extname(filename);
      raw = readData(filename);
      path.data = parseData(raw, extension);
    }
    return merge.apply(null, paths);
  };

}).call(this);
