// Generated by CoffeeScript 1.8.0
(function() {
  var PathExp, add, async, base, consolidate, content, context, contexts, data, extension, fs, groups, isCollection, layoutTemplate, location, name, outputTemplate, path, program, render, segments, trace, uniquelyIdentifies, unwrap, wrap, _, _i, _len, _ref;

  fs = require('fs');

  fs.path = require('path');

  _ = require('underscore');

  async = require('async');

  PathExp = require('simple-path-expressions').PathExp;

  consolidate = require('consolidate');

  program = require('commander');

  program.version('0.1.0').usage('<template> [options]').option('-c --context <path>', 'Input files that serve as context to your template.').option('-o, --output <path>', 'The path or path template.').option('-l --line-delimited', 'Line-delimited JSON.').option('-e, --engine <name>', 'The templating engine to use. If not specified, we guess from the extension.').option('-n, --namespaced', 'Namespace JSON input by its filename.').option('-N, --fully-namespaced', 'Namespace JSON input by its full path.').option('-i, --iterate [key]', 'Render a template once for each item.').option('-g, --group [keys]', 'Group input by keys or output placeholders.').option('-k, --key <name>', 'What name to give an array in the template context.').parse(process.argv);

  trace = function(obj, path) {
    var segment, _i, _len, _ref;
    if (path == null) {
      path = '';
    }
    _ref = _.compact(path.split('.'));
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      segment = _ref[_i];
      obj = obj[segment] != null ? obj[segment] : obj[segment] = {};
    }
    return obj;
  };

  unwrap = function(str) {
    return str.replace(/\W?\n/g, ' ');
  };

  wrap = function(obj, key) {
    var wrapped;
    wrapped = {};
    wrapped[key] = obj;
    return wrapped;
  };

  _ref = program.context.split(',');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    path = _ref[_i];
    segments = path.split(':');
    path = segments.pop();
    name = segments.pop();
    extension = fs.path.extname(path);
    content = fs.readFileSync(path, 'utf8');
    if (program.lineDelimited) {
      data = content.split('\n').map(JSON.parse);
    } else {
      data = JSON.parse(content);
    }
    if (typeof contexts === "undefined" || contexts === null) {
      switch (data.constructor) {
        case Array:
          contexts = [];
          add = function(items) {
            return contexts.push.apply(contexts, items);
          };
          break;
        case Object:
          contexts = {};
          add = function(hash) {
            return _.extend(contexts, hash);
          };
          break;
        default:
          throw new Error();
      }
    }
    if (data.constructor !== contexts.constructor) {
      throw new Error("Mixed data types.");
    }
    if (name && data.constructor !== Object) {
      throw new Error();
    }
    if (contexts.constructor === Object && !name) {
      if (program.namespaced) {
        name = fs.path.basename(path, extension);
      } else if (program.fullyNamespaced) {
        base = path.replace(extension, '');
        name = base.replace(/\//g, '.');
      }
    }
    if (name) {
      location = trace(contexts, name);
      _.extend(location, data);
    } else {
      add(data);
    }
  }

  if (typeof contexts === 'array') {
    groups = _.groupBy(contexts, function(obj) {
      return _.values(_.pick(obj, template.placeholders));
    });
    uniquelyIdentifies = _.every(_.values(groups), function(group) {
      return group.length === 1;
    });
    if (!uniquelyIdentifies && !program.group) {
      throw new Error();
    }
  }

  if (program.group) {
    if (!template.hasPlaceholders) {
      throw new Error();
    }
    if (typeof context !== 'array') {
      throw new Error();
    }
    context = groups;
  }

  layoutTemplate = new PathExp(program.args[0]);

  outputTemplate = new PathExp(program.output || '');

  isCollection = program.iterate || false;

  render = function(context, callback) {
    var engine, engineNames, engines, language, layout;
    layout = layoutTemplate.fill(context);
    extension = (fs.path.extname(layout)).slice(1);
    language = program.engine || extension;
    engines = _.pick(consolidate, function(value, key) {
      return value.render != null;
    });
    engineNames = _.keys(engines);
    engine = engines[language];
    if (!engine) {
      if (program.engine) {
        throw new Error(unwrap("Could not find a templating engine matching \n" + program.engine + ". Choose from " + engineNames));
      } else {
        throw new Error(unwrap("Could not find a templating engine matching \nthe extension " + extension + ". Please use the --engine\noption to clarify which engine you'd like to use."));
      }
    }
    if (context.constructor === Array) {
      context = wrap(context, program.key || 'items');
    }
    return consolidate[language](layout, context, function(err, html) {
      var output;
      if (err) {
        return callback(err);
      }
      if (program.output) {
        output = outputTemplate.fill(context);
        return fs.writeFile(output, html, {
          encoding: 'utf8'
        }, callback);
      } else {
        console.log(html);
        return callback(null);
      }
    });
  };

  if (!isCollection) {
    contexts = [contexts];
  }

  async.each(contexts, render, function(err) {
    if (err) {
      return console.log(err);
    }
  });

}).call(this);
